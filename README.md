## Java 可伸缩线程池 (StretchableThreadPool)

### 🛠 食用方法

```Java
// 详情见项目的测试类
public void howToUse() {
    // 1.创建可伸缩线程池对象
    StretchableThreadPool pool = new StretchableThreadPool();
    
    // 2.初始化线程池（线程池在这里需要传入四个初始化参数）
    // (1):minThreadCount 线程池最小线程数目
    // (2):maxThreadCount 线程池最大线程数目
    // (3):maxWaitSeconds 当前线程等待maxWaitSeconds秒后仍然接收不到新来的任务就会自杀
    // (4):addOnceThreadCount 线程池可以扩增时，一次批量增加的线程数
    pool.initThreadPool(5, 15, 3, 5);
    
    // 3.将你需要执行的任务用createNewWork方法放入线程池中执行
    // 由于Java不支持函数式编程，这里要传入Runnable接口的子实现类，重写run方法作为你要执行的真正任务
    pool.createNewWork(new ActualWork(10));
}

@Slf4j
@AllArgsConstructor
class ActualWork implements Runnable {
    // 可以用成员变量支持参数传递（由于Runnable不支持参数传递）
    private Integer workId;

    @Override
    public void run() {
        // 1.工作时打印当前任务的ID号
        log.info("work {} run in the thread pool", workId);
        // 2.当前线程睡上5s（模拟当前线程处理该任务5s）
        try {
            Thread.sleep(5 * 1000);
        } catch (InterruptedException e) {
            log.error(e.getMessage());
        }
        // 3.当前任务结束
        log.info("work {} end", workId);
    }
}
```

### 🌍 设计原则

#### 🔒 锁设计

> 只设置一把“大”的互斥锁，由于任务队列和线程池列表均使用了**非同步**的数据结构，**因此需要这把锁同时锁住线程池对象和任务队列对象**。涉及到添加新任务和线程内任务调度时均需要使用这把锁进行同步控制（保证同一时刻始终只有一个线程持有锁，不会出现死锁现象）。
>
> 使用时只涉及一把锁，这种设计有效地**防止了死锁现象**的发生，这把锁**只有在线程后台真正执行用户传入的任务对象时被释放**（任务执行完毕后重新与其它线程竞争锁恢复状态），保证了操作的原子性。由于线程要执行的任务时间长而这些其它原子性操作执行速度快，因此这种设计又不失线程池“后台”多线程执行任务的高效性。

#### 🔨 调度原则（线程自身调度自身）

<img src="img/task-arrangement.svg" alt="task-arrangement" style="zoom:80%;" />

> 每个线程均在一个 while(true) 循环中不断循环等待任务，调度主要分为以下情况

- 当前线程在循环中一上来就发现任务队列中存在可执行的任务，那么就取出该任务执行
- 当前线程一上来没有发现任务队列中存在可执行的任务，那么就**进入该锁的一个条件变量上进行超时等待**（**等待的同时释放对象锁**，其他线程也可以竞争锁判断）
  - 若当前线程等待未超时，**一定说明任务队列中出现了新的任务**（**创建任务时，会往条件变量里发 signal 信号随机唤醒其中的一个正在超时等待的线程工作**），此时这个被唤醒的线程重新进入循环抢锁执行新任务，如果有机会抢到锁就可以执行新任务，没有抢过其他线程就继续等待
  - 若当前线程等待超过预设的超时等待时间，这时候当前线程要**检查是否可以自杀**，如果当前线程满足自杀条件，那么当前线程自杀从而退出任务循环，线程池线程数量缩减；若不可以自杀则继续进入任务循环

#### 🎨 线程池线程数量动态伸缩原则

> 动态增加线程数目：在创建任务时检查当前线程池是否存在空闲的线程，**若创建新任务时不存在空闲线程且当前线程池中线程总数小于预设的 maxThreadCount 最大线程数量**，说明可以动态扩充，**一次批量增加 addOnceThreadCount 个数目**的线程。
>
> 动态缩减线程数目：每个线程在自身的任务循环中若**等待超时（在条件变量中等待 maxWaitSeconds 秒后仍然没有收到条件变量发来的新任务来临信号，这个线程继续等也没有意义）**，**若当前线程池线程数大于预设的线程池最小线程数 minThreadCount ，说明当前线程可以自杀，线程池动态缩减**，若当前线程池线程数已经是预设的线程池最小线程数，不可以自杀，继续循环接受任务。

#### 📌 设计模式-策略模式

> 使用 Runnable 接口聚合在线程池的任务对象中，使用时可以动态传入自身覆写的策略对象作为实际任务对象传入线程池，利用多态使任务队列不依赖于某个具体任务而依赖于一个抽象的通用接口，可拓展性强，耦合度低